name: Platform Engineering Build Pipeline
permissions:
  security-events: write
  contents: read
  actions: write
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-north-1

jobs:
  terraform-validate:
    name: Terraform Validate
    runs-on: ubuntu-latest
    outputs:
      cluster-name: ${{ steps.tf-output.outputs.cluster-name }}
      backstage-ecr-url: ${{ steps.tf-output.outputs.backstage-ecr-url }}
      main-app-ecr-url: ${{ steps.tf-output.outputs.main-app-ecr-url }}
    steps:
    - uses: actions/checkout@v4
    - uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - working-directory: ./infra
      run: terraform fmt -check
    - working-directory: ./infra
      run: terraform init
    - working-directory: ./infra
      run: terraform validate
    - working-directory: ./infra
      run: terraform plan -no-color
      continue-on-error: true
    - id: tf-output
      working-directory: ./infra
      run: |
        if terraform state list > /dev/null 2>&1; then
          echo "cluster-name=$(terraform output -raw cluster_name 2>/dev/null || echo 'cluster-pending')" >> $GITHUB_OUTPUT
          echo "backstage-ecr-url=$(terraform output -raw backstage_ecr_repository_url 2>/dev/null || echo 'ecr-pending')" >> $GITHUB_OUTPUT
          echo "main-app-ecr-url=$(terraform output -raw platform_engineering_ecr_repository_url 2>/dev/null || echo 'ecr-pending')" >> $GITHUB_OUTPUT
        else
          echo "cluster-name=cluster-pending" >> $GITHUB_OUTPUT
          echo "backstage-ecr-url=ecr-pending" >> $GITHUB_OUTPUT
          echo "main-app-ecr-url=ecr-pending" >> $GITHUB_OUTPUT
        fi

  build-app:
    name: Build Application
    runs-on: ubuntu-latest
    needs: terraform-validate
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'yarn'
        cache-dependency-path: './backstage/yarn.lock'
    - working-directory: ./backstage
      run: yarn install --frozen-lockfile
    - working-directory: ./backstage
      run: yarn build:backend
    - working-directory: ./backstage
      run: yarn build:all
    - working-directory: ./backstage
      run: yarn test --passWithNoTests --watchAll=false

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: github.ref == 'refs/heads/main'
    outputs:
      cluster-name: ${{ steps.tf-outputs.outputs.cluster-name }}
      backstage-ecr-url: ${{ steps.tf-outputs.outputs.backstage-ecr-url }}
      main-app-ecr-url: ${{ steps.tf-outputs.outputs.main-app-ecr-url }}
    steps:
    - uses: actions/checkout@v4
    - uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - working-directory: ./infra
      run: terraform init
    - working-directory: ./infra
      run: terraform apply -auto-approve
    - id: tf-outputs
      working-directory: ./infra
      run: |
        echo "cluster-name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
        echo "backstage-ecr-url=$(terraform output -raw backstage_ecr_repository_url)" >> $GITHUB_OUTPUT
        echo "main-app-ecr-url=$(terraform output -raw platform_engineering_ecr_repository_url)" >> $GITHUB_OUTPUT
        echo "Cluster Name: $(terraform output -raw cluster_name)"
        echo "Backstage ECR: $(terraform output -raw backstage_ecr_repository_url)"
        echo "Main App ECR: $(terraform output -raw platform_engineering_ecr_repository_url)"

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [build-app, deploy-infrastructure]
    if: github.ref == 'refs/heads/main'
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
    - uses: actions/checkout@v4
    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - uses: aws-actions/amazon-ecr-login@v2
      id: login-ecr
    - uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'yarn'
        cache-dependency-path: './backstage/yarn.lock'
    - working-directory: ./backstage
      run: yarn install --frozen-lockfile
    - working-directory: ./backstage
      run: |
        yarn build:backend
        yarn build-image --tag temp-backstage-image
        echo "Listing Docker images:"
        docker images | grep temp-backstage-image
    - id: build
      run: |
        IMAGE_ID=$(docker images temp-backstage-image --format "{{.ID}}" | head -n 1)
        if [ -z "$IMAGE_ID" ]; then
          echo "Error: No image found with name 'temp-backstage-image'"
          exit 1
        fi
        echo "Image ID: $IMAGE_ID"
        ECR_URL="${{ needs.deploy-infrastructure.outputs.backstage-ecr-url }}"
        docker tag $IMAGE_ID $ECR_URL:${{ github.sha }}
        docker tag $IMAGE_ID $ECR_URL:latest
        docker push $ECR_URL:${{ github.sha }}
        docker push $ECR_URL:latest
        echo "image-tag=$ECR_URL:${{ github.sha }}" >> $GITHUB_OUTPUT
        DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $ECR_URL:${{ github.sha }} 2>/dev/null | cut -d'@' -f2 || echo "digest-unavailable")
        echo "digest=$DIGEST" >> $GITHUB_OUTPUT

  deploy-to-eks:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, build-and-push]
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v4
    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - run: |
        CLUSTER_NAME="${{ needs.deploy-infrastructure.outputs.cluster-name }}"
        echo "Updating kubeconfig for cluster: $CLUSTER_NAME"
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name $CLUSTER_NAME
        kubectl get nodes
    - run: |
        if [ ! -f deployment.yml ]; then
          cat > deployment.yml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: backstage-deployment
          labels:
            app: backstage
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: backstage
          template:
            metadata:
              labels:
                app: backstage
            spec:
              containers:
              - name: backstage
                image: IMAGE_TAG
                ports:
                - containerPort: 7007
                env:
                - name: NODE_ENV
                  value: "production"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: backstage-service
        spec:
          selector:
            app: backstage
          ports:
            - protocol: TCP
              port: 80
              targetPort: 7007
          type: LoadBalancer
        EOF
        fi
        sed -i 's|IMAGE_TAG|${{ needs.build-and-push.outputs.image-tag }}|g' deployment.yml
        kubectl apply -f deployment.yml
        kubectl rollout status deployment/backstage-deployment --timeout=300s
        kubectl get services
        kubectl get pods

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-and-push
    if: always()
    steps:
    - uses: actions/checkout@v4
    - uses: aquasecurity/trivy-action@0.11.0
      with:
        image-ref: ${{ needs.build-and-push.outputs.image-tag }}
        format: sarif
        output: trivy-results.sarif
      working-directory: ./backstage
      continue-on-error: true
    - working-directory: ./backstage
      run: ls -l trivy-results.sarif || echo "SARIF file not found"
    - uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: ./backstage/trivy-results.sarif

  cleanup:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-to-eks]
    if: failure() && github.ref == 'refs/heads/main'
    steps:
    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - run: |
        kubectl delete deployment backstage-deployment --ignore-not-found=true
        kubectl delete service backstage-service --ignore-not-found=true
